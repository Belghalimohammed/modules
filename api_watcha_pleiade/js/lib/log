import { RoomEvent, createClient, MemoryStore, Filter } from "matrix-js-sdk";
import {
  fetchMatrixConfig,
  fetchMatrixNotifications,
  renderMessages,
  handleLiveInvitations,
  handleLiveMessage,
  removeItemsOnReceipt,
  updateItemsOnReceipt,
  filter,
} from "./matrix-utils.js";

let toStartOfTime;
let matrixClient, startTs;
let myUserId, myAccessToken, synapseServer, watchaUrl, synapseServerApi;
let watchaBar, container;

// ---------------- CLIENT CREATION ----------------

function createMatrixClient() {
  return createClient({
    baseUrl: synapseServer,
    accessToken: myAccessToken,
    userId: myUserId,
    store: new MemoryStore(),
    useAuthorizationHeader: true,
    initialSyncLimit: 0,
  });
}

// ---------------- MAIN INIT ----------------
let nextBatch = null;
async function initMatrixClient() {
  try {
    const config = await fetchMatrixConfig();
    if (!config) return;
  
    ({ myUserId, myAccessToken, synapseServer, synapseServerApi, watchaUrl } =
      config);
    
  

    matrixClient = createMatrixClient();



  

startSyncLoop(container,watchaBar,watchaUrl,myUserId);

   
  } catch (err) {
    console.error("Matrix initialization error:", err);
  }
}

// ---------------- DOM READY ----------------

function waitForElementsAndStart() {
  const observer = new MutationObserver(() => {
    const refs = {
      container: document.getElementById("watcha_block_id"),
      watchaBar: document.getElementById("watcha"),
    };

    if (Object.values(refs).every(Boolean)) {
      ({ container, watchaBar } = refs);

      observer.disconnect();
      if (refs.container) {
        localStorage.setItem("notificationsCount", "0");
        initMatrixClient();
      }
    }
  });

  observer.observe(document.body, { childList: true, subtree: true });
}

document.addEventListener("DOMContentLoaded", waitForElementsAndStart);

const globalNotifications = {};



// Fetch with filter and then follow up with filter=0
async function startSyncLoop(container,watchaBar,watchaUrl,myUserId) {
  try {
    // Step 1: Initial sync with full filter
 

    const initUrl = `${synapseServer}/_matrix/client/v3/sync?filter=%7B%22room%22%3A%7B%22timeline%22%3A%7B%22unread_thread_notifications%22%3Atrue%2C%22limit%22%3A20%7D%2C%22state%22%3A%7B%22lazy_load_members%22%3Atrue%7D%7D%7D&full_state=false`;
    const initialRes = await fetch(initUrl, {
      headers: {
        Authorization: `Bearer ${myAccessToken}`
      }
    });

    if (!initialRes.ok) {
      throw new Error("Initial sync failed");
    }

    const initialData = await initialRes.json();
    nextBatch = initialData.next_batch;
     renderMessages(await handleSyncResponse(initialData,true), {
      container,
      watchaBar,
      watchaUrl,

      myUserId,
    });
   // console.log(await handleSyncResponse(initialData,true));

    // Step 2: Continue syncing every 1 second with filter=0
    setInterval(()=>{syncWithFilter0(container,watchaBar,watchaUrl,myUserId)}, 1000);

  } catch (err) {
    console.error("Sync loop error:", err.message);
  }
}

// Sync every second with filter=0
async function syncWithFilter0(container,watchaBar,watchaUrl,myUserId) {
  if (!nextBatch) return;

  const url = `${synapseServer}/_matrix/client/v3/sync?filter=%7B%22room%22%3A%7B%22timeline%22%3A%7B%22unread_thread_notifications%22%3Atrue%2C%22limit%22%3A20%7D%2C%22state%22%3A%7B%22lazy_load_members%22%3Atrue%7D%7D%7D&full_state=false&since=`+nextBatch;
  try {
    const res = await fetch(url, {
      headers: {
        Authorization: `Bearer ${myAccessToken}`
      }
    });

    if (!res.ok) {
      throw new Error("Sync with filter=0 failed");
    }

    const data = await res.json();
    nextBatch = data.next_batch;
    console.log(await handleSyncResponse(data,false));
      renderMessages(await handleSyncResponse(data,false), {
      container,
      watchaBar,
      watchaUrl,

      myUserId,
    });
  } catch (err) {
    console.error("Sync error:", err.message);
  }
}


function getMxcUrl(mxcUrl) {
  if (!mxcUrl) return null;
  const mediaId = mxcUrl.replace("mxc://", "");
  return `${synapseServer}/_matrix/media/v3/download/${mediaId}`;
}

const roomMemberCache = {}; // Persistent cache across syncs

async function handleSyncResponse(data, isInitial = false) {
  const joinedRooms = data.rooms?.join ?? {};
  const inviteRooms = data.rooms?.invite ?? {};

  // âœ… Joined Rooms
  for (const [roomId, roomData] of Object.entries(joinedRooms)) {
    const notifCount = roomData.unread_notifications?.notification_count ?? 0;
    if (notifCount === 0) continue;

    let roomName = roomId;

    // Init member cache if needed
    if (!roomMemberCache[roomId]) roomMemberCache[roomId] = {};
    const roomMembers = roomMemberCache[roomId];

    const stateEvents = roomData.state?.events ?? [];
    const timelineEvents = roomData.timeline?.events ?? [];

    // On initial sync, collect from state events
    if (isInitial) {
      for (const event of stateEvents) {
        if (event.type === "m.room.member") {
          roomMembers[event.state_key] = {
            displayname: event.content?.displayname,
            avatar_url: event.content?.avatar_url,
          };
        }
        if (event.type === "m.room.name") {
          roomName = event.content?.name ?? roomName;
        }
      }
    }

    // Update room name if it changed in timeline
    for (const event of timelineEvents) {
      if (event.type === "m.room.name") {
        roomName = event.content?.name ?? roomName;
      }
      if (event.type === "m.room.member") {
        roomMembers[event.state_key] = {
          displayname: event.content?.displayname,
          avatar_url: event.content?.avatar_url,
        };
      }
    }

    const editsMap = {};
    const events = timelineEvents.slice().reverse();
    let lastMessage = null;

    for (const event of events) {
      const type = event.type;
      const sender = event.sender;
      const content = event.content ?? {};
      const rel = content?.["m.relates_to"]?.rel_type;
      const isRedacted = !!event.unsigned?.redacted_by;

      // Handle deleted messages
      if (isRedacted) {
        if (globalNotifications[roomId]?.event_id === event.event_id) {
          delete globalNotifications[roomId];
        }
        continue;
      }

      if (rel === "m.replace") {
        const targetId = content["m.relates_to"]?.event_id;
        if (targetId) editsMap[targetId] = content;
        continue;
      }

      if (type !== "m.room.message") continue;
      if (rel === "m.thread") continue;
      if (sender === myUserId) continue;

      lastMessage = event;
      break;
    }

    if (lastMessage) {
      const senderId = lastMessage.sender;
      let body = lastMessage.content?.body ?? "";

      if (editsMap[lastMessage.event_id]) {
        body = editsMap[lastMessage.event_id]["m.new_content"]?.body ?? body;
      }

      let senderData = roomMembers[senderId];

      // If sender not cached, fallback to /profile API
      if (!senderData) {
        try {
          const profileRes = await fetch(`${synapseServer}/_matrix/client/v3/profile/${encodeURIComponent(senderId)}`, {
            headers: { Authorization: `Bearer ${myAccessToken}` },
          });
          if (profileRes.ok) {
            const profile = await profileRes.json();
            senderData = {
              displayname: profile.displayname,
              avatar_url: profile.avatar_url,
            };
            roomMembers[senderId] = senderData;
          } else {
            senderData = {};
          }
        } catch (err) {
          console.warn(`Failed to fetch profile for ${senderId}:`, err.message);
          senderData = {};
        }
      }

      const displayName = senderData?.displayname ?? senderId;
      const avatarUrl = getMxcUrl(senderData?.avatar_url);

      globalNotifications[roomId] = {
        type: "unread",
        room_id: roomId,
        room_name: roomName === roomId ? "direct" : roomName,
        unread: notifCount,
        message: body,
        sender: displayName,
        avatar_url: avatarUrl,
        sender_id: senderId,
        timestamp: lastMessage.origin_server_ts,
        event_id: lastMessage.event_id,
      };
    }
  }

  // ğŸ“¨ Invited Rooms
  for (const [roomId, inviteData] of Object.entries(inviteRooms)) {
    let roomName = "Invite";
    let inviter = null;
    let timestamp = null;

    for (const event of inviteData.invite_state?.events ?? []) {
      if (event.type === "m.room.name") {
        roomName = event.content?.name ?? roomName;
      }
      if (event.type === "m.room.member" && event.sender) {
        inviter = event.sender;
        timestamp = event.origin_server_ts;
      }
    }

    let displayName = inviter;
    let avatarUrl = null;

    for (const event of inviteData.invite_state?.events ?? []) {
      if (event.type === "m.room.member" && event.state_key === inviter) {
        displayName = event.content?.displayname ?? inviter;
        avatarUrl = getMxcUrl(event.content?.avatar_url);
        break;
      }
    }

    globalNotifications[roomId] = {
      type: "invite",
      room_id: roomId,
      room_name: roomName,
      sender: displayName,
      avatar_url: avatarUrl,
      sender_id: inviter,
      timestamp,
      unread: 1,
    };
  }

  return { ...globalNotifications };
}




------------------------------

export function renderMessages(notifications, options) {
  const { container, watchaBar, watchaUrl } = options;

 

  let mergedNotifications = Object.values(notifications);

  if (mergedNotifications.length === 0) {
    showEmptyMessage(container, watchaBar);
    return;
  }

  container.innerHTML = "";
  updateTabTitle(mergedNotifications.length, watchaBar);

 

  mergedNotifications
    .sort((b, a) => new Date(b.timestamp) - new Date(a.timestamp))
    .forEach((event) => {
      displayMessageNoth(
        event.event_id,
        event.type,
        event.room_name === "(no name)" ? event.sender : event.room_name,
        event.unread,
        event.sender,
        event.avatar_url,
        formatTimestamp(event.timestamp),
        event.message || "",
        event.room_id,
        watchaBar,
        container,
        watchaUrl
      );
    });
}



------------------------



export function updateTabTitle(inc, watchaBar) {
  const currentCount = 0;
  const newCount = Math.max(0, currentCount + inc);
  sessionStorage.setItem("notificationsCount", newCount.toString());

  const baseTitle = sessionStorage.getItem("baseTabTitle") || document.title.trim();
  document.title = newCount > 0 ? `[${newCount}] ${baseTitle}` : baseTitle;

  document.querySelectorAll(".noth-span").forEach(el => el.remove());

  if (watchaBar && newCount > 0) {
    const badge = `
      <span class="noth-span">
        <span class="position-absolute start-75 translate-middle badge rounded-pill bg-danger">
          ${newCount}
        </span>
      </span>`;

    document.querySelector("#territoirenumriqueouvertprod > span")?.insertAdjacentHTML("beforeend", badge);
    watchaBar.insertAdjacentHTML("beforeend", badge);
    watchaBar.dataset.value1 = newCount.toString();
  }
}